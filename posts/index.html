<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>just for fun!</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content><meta name=generator content="Hugo 0.85.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/ananke/css/main.min.css><link href=/posts/index.xml rel=alternate type=application/rss+xml title="just for fun!"><link href=/posts/index.xml rel=feed type=application/rss+xml title="just for fun!"><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://example.org/posts/"><meta itemprop=name content="Posts"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content></head><body class="ma0 avenir bg-near-white"><header><div class="pb3-m pb6-l bg-black"><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">just for fun!</a><div class="flex-l items-center"></div></div></nav><div class="tc-l pv3 ph3 ph4-ns"><h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">Posts</h1></div></div></header><main class=pb7 role=main><article class="pa3 pa4-ns nested-copy-line-height nested-img"><section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section><section class="flex-ns flex-wrap justify-around mt5"><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/%E8%BD%AF%E4%BB%B6%E4%B8%AD%E9%97%B4%E5%B1%82/ class="link black dim">软件中间层</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">计算机领域有句名言
计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决
最近在工作中我就通过增加中间层来解决了看似需要换方案或推倒重来的问题。
监控告警 因为前司的监控告警方案是我拟定并实现的，用的是Prometheus生态那一套，基本上是以下思路
prometheus：数据收集 alertmanager：接收告警 webhook：告警通道分发 exporter：指标采集 grafana：可视化 想的很美好，遇到的第一个问题可把我愣住了：
公司近期做降本增效，这些服务的虚拟机申请不给批； 公司有人在用prometheus,但都是历史原因自已用，没专人维护 因为开源时序数据库性能不能满足需求，公司开发了独立的数据采集方案：tracer(不同于prometheus的exporter） 团队监控业务与公司数据采集服务不在同一网络 根据与运维部门的沟通，我得到的结果：
你不能自己玩prometheus那一套，我们不会给资源的 你可以用公司的数据采集方案，但是需要你自己将监控指标数据转成tracer的格式 你可以等待运维部门出兼容方案，因为人员有限，这一季度调研，下季度落地 此处必须引用老玩家C的一条微博
什么是工程思维？——永远以资源有限、条件不足为前提，去实现现实世界的目标。
这不正是资源有限，条件不足的现实场景吗？prometheus这一套体系我是熟悉的，必须接入公司的tracer，加一个中间层？
prometheus配置remote write到数据转换服务S 服务S将prometheus数据转换成tracer格式，并上传到公司的数据采集服务 由于接入公司监控系统，所以很自然可以借力公司的告警系统，不必自己写webhook了 所以你看，通过使用中间层服务S，我使用了自己熟悉的技术，又可以借力公司现有的能力，其实问题并没有想像中那么难，不是吗？
网关配置 之前吐槽过目前我正在使用的网关：krakend,原因就在于它的配置复杂且繁琐，不支持正则，模板难用，以至于随着组内微服务规模的扩张，配置成了一个不小的负担，因为团队只有我懂，只有我会配。我想换网关，以解决配置繁琐的问题，但由于手头业务重，暂时也抽不出大量时间换其它网关，况且换也是有成本和风险的，痛定思痛，我整理了一下所谓的“痛点”问题：
URI参数配置过长，且有顺序要求； URI的不同Method需要分别配置； 针对这两个问题，其实很容易想到简化配置的方案，在配置文件和网关真正载入配置中间加一个中间层，将简化的配置转化成网关的繁杂配置，于是问题就变成写正则了
将{param1}/{param2}写法统一成{param}/{param}，{param}只是作为占位符 Method支持多个同时配置，如POST,GET,PUT 支持连续参数的简化语法，如{param@num}，num为3，则最后转换成{param1}/{param2}/{param3}的形式 而且兼容新老写法，于是配置不再是一个令人头疼的问题，而且我发现这种相对严格的配置方式其实挺好的，至少是明确的，如果使用正则，很容易会将内部不应暴露出的资源暴露出去。
这两件事情若放在以前，我大概率会使用推倒换方案的路数，但是现如今资源有限，要解决从0到1的问题，还要兼顾历史，我认为加中间层这个思路非常合适当下，既增加了灵活性，又保留了换方案的可能性，而且团队借力后，能更专注于核心业务，这或许就是成长吧。道理，都懂，只是，这一次从实践中第一次较为深刻的理解了，我相信，这对我之后的工作大有裨益。</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/api%E7%BD%91%E5%85%B3%E4%B9%8Bkrakend/ class="link black dim">API网关之krakend</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">这一篇已经拖了好久了，以至于提笔开始写的时候，krakend项目已经改名为lura了，而且这个网关项目还进入到了CNCF中，真的是士别三日，当刮目相看了。不知不觉，我使用的这个开源项目作为团队的业务网关都已经上线了。
当初我为什么要选择这个网关呢？首先团队跟外部沟通的协议为HTTP，有一些鉴权需求，本身业务量并不大，需要支持自定义插件的，最好是用golang写的，便于维护。从功能上来讲，其实nginx非常符合我的需求，除了技术栈，我只用了几天时间调研试用，就迅速确定了krakend作为API网关的框架，使用简单，性能还很强的样子。当然，从业务量上来讲，性能不是第一优先级，我需要解决的是从无到有的问题。
我所在的团队属于初创，后端这部分有好几个人在写，功能上重复，每个人都跟自己的业务前端对接，部门所做的几个功能都挺分散的，再加上权限控制的需求愈发强烈，网关的必要性就凸显出来了。短短不到百行代码，就能创建一个API网关，这是我选择的主要原因。
package main import ( "flag" "log" "os" "github.com/luraproject/lura/config" "github.com/luraproject/lura/logging" "github.com/luraproject/lura/proxy" "github.com/luraproject/lura/router/gin" ) func main() { port := flag.Int("p", 0, "Port of the service") logLevel := flag.String("l", "ERROR", "Logging level") debug := flag.Bool("d", false, "Enable the debug") configFile := flag.String("c", "/etc/lura/lura.json", "Path to the configuration filename") flag.Parse() parser := config.NewParser() serviceConfig, err := parser.Parse(*configFile) if err != nil { log.Fatal("ERROR:", err.Error()) } serviceConfig.Debug = serviceConfig.Debug || *debug if *port !</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/api%E7%BD%91%E5%85%B3%E9%80%89%E5%9E%8B/ class="link black dim">API网关选型</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">来新公司第一个月，客户端部门做后端，我应该是这个部门里面最专业的后端了吧，嗯，不能这么讲，应该是在后端领域工龄最长的人，这样描述相对客观。在这里我得知现在团队当前后端Golang项目都是客户端开发的人做的，坦白说，代码规范不太好，我随便看了几个项目，几个问题比较突出：
代码未格式化，风格凌乱; 有的项目存在很多无用甚至是错误的测试用例，导致我用VSCode打开项目会看到不少错误; 有的项目代码仓库提交了一些不该提交的文件; 数据库表结构跟代码未同步，这直接导致我需要连上数据库才能看到表的索引等内容; 普遍没有做静态检查，包括go.mod文件也存在冗余的情况; …… 表面问题看着是不少，还未检查业务逻辑，不过看似混乱的项目竟然能够支撑近半年，没有出现大的问题，这不能不说是一个奇迹，我相信我的小伙伴们都尽力了，毕竟客户端兼服务端开发，这活可并不好干，业务能从0到1做起来已经相当不错。不过，我来了，就是要解决这些问题。
首先摆在我面前的问题是后端业务比较分散，几个人各写各的，既没有代码共用，服务也没有分层，因为是内部系统，也没有做权限验证，所谓分久必合，那我想到的是先将后端系统进行整合，统一入口，将鉴权补足，于是就有了API网关的想法，需求其实比较简单：
路由 鉴权 支持自定义插件 其实nginx也能满足需求，不过由于技术栈的原因，就不考虑了，搜索google得到的几大流行网关如下：
Kong: 云原生微服务网关，大名鼎鼎，看了下文档，这家伙太重了，考虑到目前我还没有操作k8s的权限, pass APISIX: 貌似是国内的团队开发，有一个web UI，看着不错的样子，不过强依赖etcd, pass traefik：新版本支持自定义插件开发，dashboard也很漂亮，不过文档看着有点吃力，尝试了一下，还是放弃了，pass KrakenD，说它是一个API网关框架其实更合适，根据文档，我快速写出自己的网关服务，自定义插件只需要实现HandlerFunc即可，非常方便快捷，配置文件虽然有点繁琐，不支持通配符，但瑕不掩瑜，一天时间我就完成了团队网关服务的雏形。 当然肯定还有其它网关我没有调研到，所谓调研也比较粗浅，文档友好，能快速开发，优先满足当前需求，解决从无到有，后续业务支撑起来，业务自然会失去技术的发展。</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/%E4%BF%AE%E4%BB%99/ class="link black dim">修仙</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">转眼五一假期就过去了，原本计划好的更新博文也被各种琐碎的事情打乱了，一直到今天，所谓拖延症本尊就是我了。其实想写的内容也是源自于对自己生活的记录，以后才能更容易回顾一些。
今年4月初，在阔别职场整整5个月之后，终于回归了，有兴奋，更多的是兴奋，作为一个混迹职场6年多的“老油条”，我的生物钟竟然自动调节到每天5点多就醒了，中午也不用怎么睡觉，一天精神照样很充沛，这可能就是兴奋的表象吧，亦或许是回归职场，多少带来了新鲜感，总之不说是打鸡血，斗志昂扬是配得的上的。
新公司要求每个人给自己起一个具有正面意义的花名，其实我早就想好了，花名素材来源于我看过的为数不多的修仙小说：《诛仙》与《凡人修仙传》， 这两部小说都有一个共同点：都是别人推荐我看的；我第一次看都提不起兴致；都是事隔多年后偶然一次机会看完的；都不只看了一次。
缘份就是这么奇妙，其实学习的道理也莫不如此：初学时，一头雾水；再学时，似懂非懂；还学时，窥得门径；最后终是醍醐灌顶，习得万法归宗的奥妙。这正是我喜欢《诛仙》这部小说的缘由。说起来那是十年前的事情了，彼时，初入大学，在舍友带动下，第一次接触了网络游戏《诛仙》，进而开始看原著小说。当时心思单纯，对游戏不甚感冒，小说也是提不起兴致，就这样放弃了游戏跟小说。哪知四年后在我进入研究生阶段，不知何故，机缘巧合下又想起《诛仙》这部小说，在网上搜到了电子书，这一次一发不可收拾，连看2天，愣是看完了，当时的感觉已无从得知了，只知情绪中肯定是带有兴奋的。主人公张小凡身世凄苦，像极了我们这些普通人；情路更是坎坷，年少懵懂，爱的单纯爱的深沉。平凡的人儿，想要出人头地，甚至本意并不是出人头地，终究是天意，先后修习佛、道、魔三家功法，资质平庸，却凭借心性之坚，生生闯出自己的一条修炼之路，始终没有迷失本心，这是何等的难能可贵。芸芸众生，每天有多少时间是庸庸碌碌，得过且过，工作，学习，其目的究竟是什么，还是说这目的本就是从众的，随波逐流的，想要的究竟是什么，这个疑问纠缠我好久，一直到今天，我都没有觉着找到了真正的答案，答案似乎触手可及，又似乎渐行渐远。或许是这种代入感，让我多次重读《诛仙》试图从中寻找到答案，而主角，不再是我唯一关注的人，我的注意力，移到了另一个大人物身上：万剑一。这是何等惊才绝艳啊，剑眉星目，白衣似雪，手握斩龙剑，于修炼一途，是真正的大佬，关键是人家还不藏着掖着，乐于分享，放在当下，实在是难能可贵，难怪一众师兄弟，都愿意跟随他，远赴西北蛮荒，深入魔教，虽死无憾了。在职场的这几年里，我一直想要跟随这样的人，与其共事，为其效力，颇有一种奉其为主的意思，但现实终归不是修仙，数年间，我也就遇到过一位这样的人，也正是因为跟随了这样一位大佬，我逐渐建立起自信，甚至是自负，在其身边学到的技能，受用至今，心中的感激，是无法言语的。当年我被这位大佬“选中”，据其本人所说是因为当时的我特别像是《诛仙》中一人物：田不易，看似愚钝，实则性子坚忍，内秀于心，这么说倒是也挺恰当的。
既然跟随很难，为何不成为呢？看《凡人修仙传》我记得是因为鬼脚七的推荐，初看也是乏味。在今年年初老婆坐月子期间，无聊时看的，结果又是一发不可收拾，当然，看完差不多花了半个月。主人公韩立同样是资质平庸之辈，一介凡人，偶然得知修仙一说，巧合之下，误入修仙一途，一路小心谨慎，却也遭遇不少困境，凭借谨慎的心性，超人的意志力，冲破万难，愣是在万年内，修成正果，飞升仙界。要说韩立，更接近于我们现实意义上的普通人，家境普通，资质普通，长相普通，优点是凡事三思而后行，有点小聪明，防人但不害人，像极了市井社会人，你要说他是好人，不算，坏人，也不是，他有自私的一面，有时也会展露善良，他始终以修仙为目的，步步为营，不放过任何一个可以提升修为的机会。我们这些农村来的孩子，没有强大的后盾，不正应该像他这样，方可在这偌大的城市中立足吗？现实中，却不会有那么多机会可言，往往努力，不一定会有收获，所以如今才有躺平一说，不努力也是一种选择吧，但是自己终究不是一个人，不努力，身边的亲人可怎么办？有时候觉着并不是自己有多想努力，是被什么事情推着走；有时又很想坚定的努力，搏一把，却又不知为何而搏，往后生活的尽头，很近又很远，近的是周遭泛滥的焦虑，远的是人生很长。与其期待遇到贵人，不如自己踏实前进，然而心志不受外物所扰，终究不是一件容易的事情。努力吧，或许，为了自己，也为了亲友，更为了自己一息尚存的的技术理想，还有热情，不辜负这短短几十年的人生。
花名，就叫剑一喽，要成为这样一个人，虽然，生活中能影响到的人真的非常非常有限，但是能给人带来积极的影响，哪怕是灵光一现，那该是多么美妙的事情；当然，如果能跟这样的人共事，甚至是成为朋友，那就更加绝妙了。人生或许就是一场修仙之旅吧，目前，我已筑基成功，接近假丹境界，这一路，我很平凡，但绝不平庸！</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/gomod%E4%BE%9D%E8%B5%96%E5%8C%85%E5%A4%84%E7%90%86/ class="link black dim">go mod依赖包处理</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">自从golang原生支持go mod以后，将golang应用依赖处理统一和标准化了，但是在使用中还是会遇到一些问题，比如以下go.mod
module github.com/wowchemy/starter-blog go 1.14 require ( github.com/wowchemy/wowchemy-hugo-modules/wowchemy v0.0.0-20210209220000-aa4fe0c75726 // indirect github.com/wowchemy/wowchemy-hugo-modules/wowchemy-cms v0.0.0-20210209220000-aa4fe0c75726 // indirect ) 这是我的博客使用的模板，需要依赖github.com/wowchemy/wowchemy-hugo-modules/wowchemy，可以看到版本号v0.0.0-20210209220000-aa4fe0c75726由tag+commit时间+commit哈希组成，因为github.com/wowchemy/starter-blog新版本存在bug，已经在github.com/wowchemy/wowchemy-hugo-modules/wowchemy中得到修复，所以我需要改一下依赖的版本，当然我可以去查看bug修复的日期以及commit哈希，然后拼接下go mod所支持的格式，但是总感觉不太方便，于是摸索出一种方法，通过commit哈希获取依赖的版本号，具体操作如下：
➜ curl https://goproxy.cn/github.com/wowchemy/wowchemy-hugo-modules/wowchemy/@v/3cf9f6c.info {"Version":"v0.0.0-20210215224117-3cf9f6cdeef0","Time":"2021-02-15T22:41:17Z"} 可以看到v0.0.0-20210215224117-3cf9f6cdeef0即是我需要的版本号，开式也很简单
|-----------------------依赖项---------------------| |-哈希-| https://goproxy.cn/github.com/wowchemy/wowchemy-hugo-modules/wowchemy/@v/3cf9f6c.info 当然，如果能用信赖项的tag尽量用tag, 这也是go官方建议的做法。</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/%E8%AE%B0%E4%B8%80%E6%AC%A1http%E8%BF%9E%E6%8E%A5%E9%87%8D%E7%94%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/ class="link black dim">记一次HTTP连接重用问题分析</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">最近新发现了一个开源项目叫pyroscope:一个开源持续Profiling平台。 之所以关注到这个开源项目跟我以前的一个想法有一些契合，所以就先照着官方文档，写了个样例试用
package main import ( "github.com/gin-gonic/gin" "github.com/pyroscope-io/pyroscope/pkg/agent/profiler" ) func main() { profiler.Start(profiler.Config{ ApplicationName: "backend.purchases", ServerAddress: "http://localhost:4040", }) r := gin.Default() r.GET("/ping", func(c *gin.Context) { c.JSON(200, gin.H{ "message": "pong", }) }) r.Run() } 先把服务跑起来再说，结果却发现Agent上送Profiler经常会有EOF错误，这让我觉得有点尴尬，看到Issues上有人提了这个问题，在好奇心驱使下，准备看看怎么回事
抓包分析 用wireshark抓包看了一下 发现竟然是服务端在先关闭连接，此时我还未看代码，直接上此类服务应该用长连接才对，翻看服务端代码也是常规写法
s := &http.Server{ Addr: ctrl.cfg.Server.ApiBindAddr, Handler: mux, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 &lt;&lt; 20, ErrorLog: golog.New(w, "", 0), } Agent端了也是默认长连接的
&http.Client{ Transport: &http.Transport{ MaxConnsPerHost: cfg.UpstreamThreads, }, Timeout: cfg.UpstreamRequestTimeout, } 所以其实两端都是支持长连接的，但连接确实是首先由服务端关闭的，这不合理啊，回头再来看抓包信息，Agent发送了[FIN, ACK]以后，还发了一次POST请求，正常情况Server端应该回一个ACK，不过由于经过了[FIN]->[FIN, ACK]此时服务端已经处于FIN_WAIT_1状态了，正等对端回ACK和FIN，不过比较巧的是刚好Agent端此时发关了一个POST请求，此时服务端只能收数据，不能发送数据，所以服务端发回了一个RST 原因是什么？ 现象分析完了，那为什么会出现这种情况呢？网上看到一些此类问题解决办法是客户端处理POST请求直接Close关掉连接，这个就没法复用连接了，而且场景不同，根本不应该这么暴力操作，还是要具体问题具体分析的。关注一个小细节，在Agent发起[SYN]建立连接到Server发起[FIN]关注连接时间间隔正好是10s，这个时间与Server的读写超时时间相同，而Agent的上送Profiler的默认时间间隔也是10s，这之间会不会有什么关系？因为理想情况至少客户端是应该复用这个连接的，直觉上应该是Agent端关闭连接才对的。果不其然，在server.</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/golang%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E9%99%B7%E9%98%B1/ class="link black dim">golang调度器的一个陷阱</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">让我们快速进入问题，不浪费时间。试着执行下面的golang代码片段。
package main import ( "fmt" "runtime" "time" ) func main() { var x int threads := runtime.GOMAXPROCS(0) println(threads) for i := 0; i &lt; threads; i++ { go func() { for { x++ } }() } time.Sleep(time.Second) fmt.Println("x =", x) } 运行代码
$ GOMAXPROCS=8 go run x.go (旁注：熟悉Golang的同道想必知道GOMAXPROCS其实对应的CPU核心数，也就是线程数，这里应该是原作者运行示例时的计算机的CPU核数为8，因为根据文档定义，如果runtime.GOMAXPROCS(0)传入参数小于1，如果特殊指定，GOMAXPROCS就等于CPU核心数)
你观察到程序从未终止吗？这就是我说的golang陷阱。如果你用C/C++写同样的程序，你就不会发现这样的问题。现在让我们修改程序，修改以下一行：
threads := runtime.GOMAXPROCS(0)-1 所以，我们只是减少了1个go协程的数量。如果你在这个改变后重新运行程序，你会发现程序正确地终止，并打印出结果。这非常令人惊讶，不是吗？要了解这个问题背后的原因，我们需要了解一下golang运行时和调度器的实现。
揭开调度器的神秘面纱 Golang提供了用于并发的goroutine。它们类似于线程，但它们是轻量级的，开销非常小。拥有数万个goroutine的程序并不罕见，而拥有一万个pthreads代价就非常高了。golang在用户态中实现了goroutine。golang运行时为go程序创建的操作系统线程（pthreads）等于GOMAXPROCS的数量。Go协程被golang运行时安排在这些有限的OS线程上。
操作系统调度器 让我们回顾一下操作系统是如何调度进程的。通常情况下，操作系统调度器会保存一份操作系统进程的列表，它们处于正在运行、可运行或不可运行的状态。如果一个进程的运行时间超过了调度器的时间片，它就会抢占该进程，并安排在同一CPU上执行另一个可运行的进程。抢占是通过定时器中断来实现的。定时器中断的频率为调度器时间片的间隔。在一段代码中正在执行的进程会停止执行，保存进程执行上下文并执行中断处理程序。中断处理程序会将执行切换到调度器中。现在，调度器可以决定在这个CPU上执行哪个可运行的进程。调度器会选择一个进程并切换到它的执行上下文。
Golang的调度器 Golang实现了一个可协作的抢占式调度器。它没有实现基于定时器中断的抢占。但是，这个调度器应该方便在一个OS线程上同时运行多个goroutine。Golang在运行时提供的构造体、库和系统调用(？此处翻译的不好，构造体这个说法听着怪怪的)中加入钩子，可以与调度器进行协作。由于它避开了调用进入调度器的计时器，所以将运行时提供的函数作为进入调度器的入口。如果我们设法写一个不使用任何运行时提供的封装函数的goroutine，会发生什么？这正是这里发生的事情。那个goroutine不会调用到调度器，并导致goroutine的抢占。
在上面的程序中，我们执行的goroutine等于GOMAXPROCS（操作系统线程）。主协程是一个额外的goroutine。每个go协程都运行一个无限循环，并带有一个整数增量操作，这为协程提供了没有调用到调度器的范围。因此，所有六个线程（GOMAXPROCS）都在运行无限循环，它们永远不会抢占。处于可运行状态的主协程无法执行，因为这六个线程中的任何一个线程都忙于执行无限循环，所以调度器永远不会被执行。当我们减少1个线程时，现在有一个OS线程变得空闲，能够执行主程序。
(旁注：假设系统是8个CPU，我们GOMAXPROCS减1以后运行程序，就会有一个核是空闲的，此时正好可以进入主线程中执行，虽然原作者这里写的是6，不过我觉得处于无限循环的线程应该等同于threads，当threads等于系统CPU核心数时，由于无限循环，主协程没有机会被调度到，所以就程序没法退出，当将threads头1时，主协程才有机会能够执行，GOMAXPROCS限制的是goroutine的最大并发能力，这个也是由golang自己的调度器实现的，那主协程能运行是由于golang调度所致吗？此处先埋下伏笔。 我分别在不同的go版本下运行了示例程序：1.13、1.14，得到了不同的结果，1.13符合预期，但是1.14下程序却有不同表现，主线程总能得到执行，我想这应该是因为1.14版本的go调度器有较大变化所致，此处先埋点，后开坑)
在现实世界的程序中，这种情况是不太可能发生的，因为我们可能会使用运行时提供的功能，如channels、systemcalls、fmt.Sprint、Mutex、time.Sleep至少一次。你可以在无限循环中添加一个无害的time.Sleep(0)，然后观察程序不再挂起。
结论 虽然出现这个问题的几率非常小，但还是有可能发生。解决这个问题的方法是在这种情况下，从程序中强行调用进入调度器。runtime.Gosched()的调用有利于强制进入调度器。
这篇博文的灵感来自于我的同事，他在玩golang的时候就遇到了这个问题。
(旁注：此文非常有意思，一个简单的示例，却可以发散读者对于调度器的理解，有你当然，这篇文章还没有讲解goroutine为什么轻量，这是另一个有意思的话题，欢迎一起讨论)
原文链接 pitfall-of-golang-scheduler</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E-diffiehellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2/ class="link black dim">数学之美 Diffie–Hellman密钥交换</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">作为一名coder，平时工作中真正用到数学公式的机会其实并不多，而且因为工作内容以CRUD为主，本质上是在做数据的提取与组装，很少有用到数学公式的机会，更遑论感受数学之美了（说起来当年考研数学分数高出英语不到10分，要知道数学总分150，英语总分100，不提了，说起来都是泪），直到我研究HTTPS协议时，看到Diffie–Hellman密钥交换协议，真是惊为天人，第一次感觉到了数学之美，持续数年之久，于今日成文。
什么是Diffie–Hellman密钥交换? 它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。
盗图一张 神奇之处 数学公式看着是容易让人头疼的，不过简单来讲就是
Alice与Bob两人要协定一个只有两人知道的共享密钥 Alice公开g、p、A三个数并提供给Bob Bob公开B并提供给Alice 由此Alice与Bob通过计算可以得到相同的值K，作为共享密钥，就算知道这个数学公式，但是通过公开的g、p、A、B却难以计算出a 中间人攻击 一切看起来似乎很美好，不过前面有提到不安全信道，这种方式难以防止中间人攻击
Alice的网络被Jack监听，Alice跟Bob的交互都要先通过Jack，于是Jack就可以将g、p、A伪造成g'、p'、A'（为什么要伪造呢，因为Jack目前还不知道Bob私有的数据b），Jack伪装成Alice与Bob通信，同理，得到Bob的数据B，然后伪造新的数据B'返回给Alice；所以此时其实共享密钥K其实有两个值，Alice与Jack共享的K1以及Jack与Bob共享的K2，此时Jack作为中间人，就可以窃取Alice与Bob的通讯记录了：
Alice发送使用K1加密后的数据M Jack得到M, 使用K1解密，然后使用K2加密成M' Jack将M&rsquo;发送给Bob Bob给Alice发送数据同上 虽然通信信道被窃听，但是双方是无感知的，这就是中间人攻击。
参考：
迪菲-赫尔曼密钥交换维基百科 中间人攻击</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/tcp%E7%9A%84%E5%8D%8A%E5%BC%80%E8%BF%9E%E6%8E%A5%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/ class="link black dim">TCP的半开连接抓包分析</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">什么是半开连接？ 众所周知，TCP三次握手完成才能认为是双方建立起连接，温故而知新，先回顾一下三次握手的过程
如果连接建立后不再进行任务数据交互的话，服务端直接挂了，比如断网宕机了，此时客户端是无法与服务端通信的，但是客户端并不知道这件事，此时这条TCP连接就可以认为是半开连接，还是来一条书本的定义吧：
如果在未告知另一端的情况下通信的一端关闭或是终止连接，那么就认为该条TCP连接处于半开状态
wireshark抓包 服务端开启动一个server如下所示：
➜ python3 -m http.server 12345 客户端向服务端发起请求
➜ telnet 192.168.199.183 12345 客户端启用wireshark监听12345端口 1665、1666、1667三个数据包完成握手，已知1666号包服务端的[SYN, ACK]包中，服务端告知客户端自己的窗口大小为65535 而1668号包**[TCP Window Update]**: 服务端告知客户端窗口大小为**131712**（即2058*64） 服务端窗口变大了，这属于滑动窗口相关内容，此处就不作展开了
服务端重启 服务端断网杀掉server，重开一个server，如之前的一样
➜ python3 -m http.server 12345 此时客户端输入字符a然后回车，所图3046号包所示 此时服务不再记得之前的这条连接，所以回了一个[RST]报文如下所示： 原因分析 系统用一个4四元组来唯一标识一个TCP连接，即[src_ip:src_port, dst_ip:dst_port]，从我所构造的这个半开连接抓包杨景来看，这四元组是没有发生变化的，那么问题来了：服务端如何判断是否与客户端建立起连接? 回到我们所构造的场景
服务端启动server 客户端发起连接 服务器断网杀掉并启动一个server，监听相同的端口 客户端发送数据 服务端返回RST 我们知道三次握手后server端会维护一个accept队列(当然还有SYN队列)，我们的构造的情况是server杀掉重开，虽然端口一样，但这是一个新的进程，此时accept队列自然为空，所以当客户端向这个相同ip及端口的server发送数据据，服务端自然不能识别这个连接。
不过，这个分析只是基于现象进行的推理，具体处理过程恐怕还得从socket连接及I/O过程及程序代码说起，先开个坑，欲知详情如何，且听下回分解
参考：
TCP/IP详解 卷1：协议 TCP 的那些事儿（上）</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/%E6%88%91%E7%9A%842020/%E6%88%91%E7%9A%842020/ class="link black dim">我的2020</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">2020年底喜迎女儿的诞生，这是这一年最大的惊喜也是最开心的事情了，一直到今天才有时间有心情来回顾一下自己的2020年之旅，过去几年的年终总结过于平铺直述，有点像是记流水账，今天想随性一点，说说自己的内心感受和一些比较有记忆点的事情。
2020年初记忆点最深的当然就是疫情，疫情期间都呆在宁波姐姐家中，最大的疏忽没有带上自己的MBP，以至于年初远程在家办公有点手足无措，只能借用一台Windows笔记本，真的是难用，还好在这期间工作内容不多，只是调研了一下大数据在容器化中的应用，写了一篇文章而已，调研也是用的阿里云的ECS。整体而言，在家办公感觉工作时间反而变长了，因为在家总会被各种各样的事情打断，需要不停地切换上下文，但是对于软件开发从业者，确实也没有一定需要到办公室工作的必要，远程工作只要把控得当，也未偿不可。我相信以后这一定是一种趋势，一定会成为这一行业的常态工作形式，正如10年前我相信Chrome浏览器一定会战胜IE、支付宝肯定会普及一样，就是那种讲不出理由的相信。
讲不出理由的相信，有时候也是刚愎自用，这导致了我在8月份离开了网银互联。当时团队做PaaS平台看不到赢利希望，公司核心管理层决定试水SaaS服务，当时我怎么也不相信这一策略会成功，要知道，我们只是一个11人小团队，这11人还包括2个产品、1个测试、2个前端，做SaaS能力不够，人力不够，资源也不够，怎么看都不像是会成功的样子……现在想来，做事情不就是要把不可能变可能吗？若是事情足够简单，那公司招我又何用？况且在网银这样，我可以边学习边工作，还有一个老大愿意手把手教我，而我却在团队最困难的时候选择了离开，这是逃避，这是我讨厌的那种人。这一次我学会了相信，相信的力量，相信你做的事情，相信你做的事情会成功。单就信念感这一点来说，自己还差很多。此处必须要引用 hi_heige的一句微博：
让自己可以用的那是Demo，让技术人员会用的那是工具，让傻子都会用那才是产品！
有时候，你有自认为充足的理由不相信，这导致了我的第二次“离职”。在微医的三个月，我一直在做一件我并不相信的事情，我有自己的理由，但是这个理由并没有说服我的上司，最后项目是做成了，落地了，但从推广结果看不尽如人意，事实上我也并没有支做所谓的推广，因为自己从一开始就不相信这件事能够产生领导预想中的效果和意义，不过最后最后的结果的确得由我来承担，虽然我几乎是一个光杆司令，但却被赋予的项目负责人的角色，职场就是这样，不会有太多试错机会，特别是像我这样工作多年，理应具备更多能力的“专家”。微医这个Offer得来很容易，当然离职也是最快的。我常对自己说，工作中，要么跟对人，要么做对事，两个我都想要，最后我发现，得其一都很难，更实际一点，我可以成为那个”对“的人，正如强哥当年那样，然后找到对的事，给自己的团队，2021年，在成为对的人上，我应该也愿意花更多工夫：不怕事，能抗事，会来事！
技术上，却有些迷茫了。19年打算转测开，结果发现完全不是想的那回事，没转成功，又跑去做容器开发，也是浅尝辄止，再后来又做监控，更是蜻蜓点水，本意是希望拓宽自己的职业宽度，却发现路越走越窄了，流于形式，浮于表面，整个人也特别浮躁，以至于找工作不顺利，自信也受到打击。痛定思痛，天无绝人之路，以往欠下的技术债务，迟早要还上的，那颗敬畏之心，也更甚了。年底给kratos提的PR终于被合入主干了，也算是对2020年有个交代，提醒自己并没有那么一事无成，默默无闻。2021年，熟悉某开源项目，最好能成为核心Committer。
生活上，2020年更加魔幻：5月份知道老婆怀孕后，年中顺利卖了成都的房子，又在杭州安家落户，为了小宝宝，买了人生中第一辆车，然后年底宝宝出生，也就一年时间，实现了买房买车生小孩，成为一名更符合年龄、符合儿子、丈夫、弟弟这个角色，有开心，但不是自己想成为的那个样子，同样是没有理由，对未来，也没有一个像之前的一个面试官那样有一个非常明确的规划，只是一心要拓展自己的职业边界，提高技术内功。
2021年的关键字：聚焦、坚持、信念
有点期待2021年底提笔年终总结时，会活成一个更好的自己，为自己加油！</div></div></div></div></section><ul class="pagination pagination-default"><li class="page-item disabled"><a href=# aria-disabled=true aria-label=First class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;&#171;</span></a></li><li class="page-item disabled"><a href=# aria-disabled=true aria-label=Previous class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;</span></a></li><li class="page-item active"><a href=# aria-current=page aria-label="Page 1" class=page-link role=button>1</a></li><li class=page-item><a href=/posts/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=/posts/page/2/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/2/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=http://example.org/>&copy; just for fun! 2021</a><div></div></div></footer></body></html>
<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>golang调度器的一个陷阱 | just for fun!</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="让我们快速进入问题，不浪费时间。试着执行下面的golang代码片段。
package main import ( &#34;fmt&#34; &#34;runtime&#34; &#34;time&#34; ) func main() { var x int threads := runtime.GOMAXPROCS(0) println(threads) for i := 0; i < threads; i++ { go func() { for { x++ } }() } time.Sleep(time.Second) fmt.Println(&#34;x =&#34;, x) } 运行代码
$ GOMAXPROCS=8 go run x.go (旁注：熟悉Golang的同道想必知道GOMAXPROCS其实对应的CPU核心数，也就是线程数，这里应该是原作者运行示例时的计算机的CPU核数为8，因为根据文档定义，如果runtime.GOMAXPROCS(0)传入参数小于1，如果特殊指定，GOMAXPROCS就等于CPU核心数)
你观察到程序从未终止吗？这就是我说的golang陷阱。如果你用C/C++写同样的程序，你就不会发现这样的问题。现在让我们修改程序，修改以下一行：
threads := runtime.GOMAXPROCS(0)-1 所以，我们只是减少了1个go协程的数量。如果你在这个改变后重新运行程序，你会发现程序正确地终止，并打印出结果。这非常令人惊讶，不是吗？要了解这个问题背后的原因，我们需要了解一下golang运行时和调度器的实现。
揭开调度器的神秘面纱 Golang提供了用于并发的goroutine。它们类似于线程，但它们是轻量级的，开销非常小。拥有数万个goroutine的程序并不罕见，而拥有一万个pthreads代价就非常高了。golang在用户态中实现了goroutine。golang运行时为go程序创建的操作系统线程（pthreads）等于GOMAXPROCS的数量。Go协程被golang运行时安排在这些有限的OS线程上。
操作系统调度器 让我们回顾一下操作系统是如何调度进程的。通常情况下，操作系统调度器会保存一份操作系统进程的列表，它们处于正在运行、可运行或不可运行的状态。如果一个进程的运行时间超过了调度器的时间片，它就会抢占该进程，并安排在同一CPU上执行另一个可运行的进程。抢占是通过定时器中断来实现的。定时器中断的频率为调度器时间片的间隔。在一段代码中正在执行的进程会停止执行，保存进程执行上下文并执行中断处理程序。中断处理程序会将执行切换到调度器中。现在，调度器可以决定在这个CPU上执行哪个可运行的进程。调度器会选择一个进程并切换到它的执行上下文。
Golang的调度器 Golang实现了一个可协作的抢占式调度器。它没有实现基于定时器中断的抢占。但是，这个调度器应该方便在一个OS线程上同时运行多个goroutine。Golang在运行时提供的构造体、库和系统调用(？此处翻译的不好，构造体这个说法听着怪怪的)中加入钩子，可以与调度器进行协作。由于它避开了调用进入调度器的计时器，所以将运行时提供的函数作为进入调度器的入口。如果我们设法写一个不使用任何运行时提供的封装函数的goroutine，会发生什么？这正是这里发生的事情。那个goroutine不会调用到调度器，并导致goroutine的抢占。
在上面的程序中，我们执行的goroutine等于GOMAXPROCS（操作系统线程）。主协程是一个额外的goroutine。每个go协程都运行一个无限循环，并带有一个整数增量操作，这为协程提供了没有调用到调度器的范围。因此，所有六个线程（GOMAXPROCS）都在运行无限循环，它们永远不会抢占。处于可运行状态的主协程无法执行，因为这六个线程中的任何一个线程都忙于执行无限循环，所以调度器永远不会被执行。当我们减少1个线程时，现在有一个OS线程变得空闲，能够执行主程序。
(旁注：假设系统是8个CPU，我们GOMAXPROCS减1以后运行程序，就会有一个核是空闲的，此时正好可以进入主线程中执行，虽然原作者这里写的是6，不过我觉得处于无限循环的线程应该等同于threads，当threads等于系统CPU核心数时，由于无限循环，主协程没有机会被调度到，所以就程序没法退出，当将threads头1时，主协程才有机会能够执行，GOMAXPROCS限制的是goroutine的最大并发能力，这个也是由golang自己的调度器实现的，那主协程能运行是由于golang调度所致吗？此处先埋下伏笔。 我分别在不同的go版本下运行了示例程序：1.13、1.14，得到了不同的结果，1.13符合预期，但是1.14下程序却有不同表现，主线程总能得到执行，我想这应该是因为1.14版本的go调度器有较大变化所致，此处先埋点，后开坑)
在现实世界的程序中，这种情况是不太可能发生的，因为我们可能会使用运行时提供的功能，如channels、systemcalls、fmt.Sprint、Mutex、time.Sleep至少一次。你可以在无限循环中添加一个无害的time.Sleep(0)，然后观察程序不再挂起。
结论 虽然出现这个问题的几率非常小，但还是有可能发生。解决这个问题的方法是在这种情况下，从程序中强行调用进入调度器。runtime.Gosched()的调用有利于强制进入调度器。
这篇博文的灵感来自于我的同事，他在玩golang的时候就遇到了这个问题。
(旁注：此文非常有意思，一个简单的示例，却可以发散读者对于调度器的理解，有你当然，这篇文章还没有讲解goroutine为什么轻量，这是另一个有意思的话题，欢迎一起讨论)
 原文链接 pitfall-of-golang-scheduler"><meta name=generator content="Hugo 0.85.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="golang调度器的一个陷阱"><meta property="og:description" content="让我们快速进入问题，不浪费时间。试着执行下面的golang代码片段。
package main import ( &#34;fmt&#34; &#34;runtime&#34; &#34;time&#34; ) func main() { var x int threads := runtime.GOMAXPROCS(0) println(threads) for i := 0; i < threads; i++ { go func() { for { x++ } }() } time.Sleep(time.Second) fmt.Println(&#34;x =&#34;, x) } 运行代码
$ GOMAXPROCS=8 go run x.go (旁注：熟悉Golang的同道想必知道GOMAXPROCS其实对应的CPU核心数，也就是线程数，这里应该是原作者运行示例时的计算机的CPU核数为8，因为根据文档定义，如果runtime.GOMAXPROCS(0)传入参数小于1，如果特殊指定，GOMAXPROCS就等于CPU核心数)
你观察到程序从未终止吗？这就是我说的golang陷阱。如果你用C/C++写同样的程序，你就不会发现这样的问题。现在让我们修改程序，修改以下一行：
threads := runtime.GOMAXPROCS(0)-1 所以，我们只是减少了1个go协程的数量。如果你在这个改变后重新运行程序，你会发现程序正确地终止，并打印出结果。这非常令人惊讶，不是吗？要了解这个问题背后的原因，我们需要了解一下golang运行时和调度器的实现。
揭开调度器的神秘面纱 Golang提供了用于并发的goroutine。它们类似于线程，但它们是轻量级的，开销非常小。拥有数万个goroutine的程序并不罕见，而拥有一万个pthreads代价就非常高了。golang在用户态中实现了goroutine。golang运行时为go程序创建的操作系统线程（pthreads）等于GOMAXPROCS的数量。Go协程被golang运行时安排在这些有限的OS线程上。
操作系统调度器 让我们回顾一下操作系统是如何调度进程的。通常情况下，操作系统调度器会保存一份操作系统进程的列表，它们处于正在运行、可运行或不可运行的状态。如果一个进程的运行时间超过了调度器的时间片，它就会抢占该进程，并安排在同一CPU上执行另一个可运行的进程。抢占是通过定时器中断来实现的。定时器中断的频率为调度器时间片的间隔。在一段代码中正在执行的进程会停止执行，保存进程执行上下文并执行中断处理程序。中断处理程序会将执行切换到调度器中。现在，调度器可以决定在这个CPU上执行哪个可运行的进程。调度器会选择一个进程并切换到它的执行上下文。
Golang的调度器 Golang实现了一个可协作的抢占式调度器。它没有实现基于定时器中断的抢占。但是，这个调度器应该方便在一个OS线程上同时运行多个goroutine。Golang在运行时提供的构造体、库和系统调用(？此处翻译的不好，构造体这个说法听着怪怪的)中加入钩子，可以与调度器进行协作。由于它避开了调用进入调度器的计时器，所以将运行时提供的函数作为进入调度器的入口。如果我们设法写一个不使用任何运行时提供的封装函数的goroutine，会发生什么？这正是这里发生的事情。那个goroutine不会调用到调度器，并导致goroutine的抢占。
在上面的程序中，我们执行的goroutine等于GOMAXPROCS（操作系统线程）。主协程是一个额外的goroutine。每个go协程都运行一个无限循环，并带有一个整数增量操作，这为协程提供了没有调用到调度器的范围。因此，所有六个线程（GOMAXPROCS）都在运行无限循环，它们永远不会抢占。处于可运行状态的主协程无法执行，因为这六个线程中的任何一个线程都忙于执行无限循环，所以调度器永远不会被执行。当我们减少1个线程时，现在有一个OS线程变得空闲，能够执行主程序。
(旁注：假设系统是8个CPU，我们GOMAXPROCS减1以后运行程序，就会有一个核是空闲的，此时正好可以进入主线程中执行，虽然原作者这里写的是6，不过我觉得处于无限循环的线程应该等同于threads，当threads等于系统CPU核心数时，由于无限循环，主协程没有机会被调度到，所以就程序没法退出，当将threads头1时，主协程才有机会能够执行，GOMAXPROCS限制的是goroutine的最大并发能力，这个也是由golang自己的调度器实现的，那主协程能运行是由于golang调度所致吗？此处先埋下伏笔。 我分别在不同的go版本下运行了示例程序：1.13、1.14，得到了不同的结果，1.13符合预期，但是1.14下程序却有不同表现，主线程总能得到执行，我想这应该是因为1.14版本的go调度器有较大变化所致，此处先埋点，后开坑)
在现实世界的程序中，这种情况是不太可能发生的，因为我们可能会使用运行时提供的功能，如channels、systemcalls、fmt.Sprint、Mutex、time.Sleep至少一次。你可以在无限循环中添加一个无害的time.Sleep(0)，然后观察程序不再挂起。
结论 虽然出现这个问题的几率非常小，但还是有可能发生。解决这个问题的方法是在这种情况下，从程序中强行调用进入调度器。runtime.Gosched()的调用有利于强制进入调度器。
这篇博文的灵感来自于我的同事，他在玩golang的时候就遇到了这个问题。
(旁注：此文非常有意思，一个简单的示例，却可以发散读者对于调度器的理解，有你当然，这篇文章还没有讲解goroutine为什么轻量，这是另一个有意思的话题，欢迎一起讨论)
 原文链接 pitfall-of-golang-scheduler"><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/posts/golang%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E9%99%B7%E9%98%B1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-07T15:47:25+08:00"><meta property="article:modified_time" content="2021-02-07T15:47:25+08:00"><meta itemprop=name content="golang调度器的一个陷阱"><meta itemprop=description content="让我们快速进入问题，不浪费时间。试着执行下面的golang代码片段。
package main import ( &#34;fmt&#34; &#34;runtime&#34; &#34;time&#34; ) func main() { var x int threads := runtime.GOMAXPROCS(0) println(threads) for i := 0; i < threads; i++ { go func() { for { x++ } }() } time.Sleep(time.Second) fmt.Println(&#34;x =&#34;, x) } 运行代码
$ GOMAXPROCS=8 go run x.go (旁注：熟悉Golang的同道想必知道GOMAXPROCS其实对应的CPU核心数，也就是线程数，这里应该是原作者运行示例时的计算机的CPU核数为8，因为根据文档定义，如果runtime.GOMAXPROCS(0)传入参数小于1，如果特殊指定，GOMAXPROCS就等于CPU核心数)
你观察到程序从未终止吗？这就是我说的golang陷阱。如果你用C/C++写同样的程序，你就不会发现这样的问题。现在让我们修改程序，修改以下一行：
threads := runtime.GOMAXPROCS(0)-1 所以，我们只是减少了1个go协程的数量。如果你在这个改变后重新运行程序，你会发现程序正确地终止，并打印出结果。这非常令人惊讶，不是吗？要了解这个问题背后的原因，我们需要了解一下golang运行时和调度器的实现。
揭开调度器的神秘面纱 Golang提供了用于并发的goroutine。它们类似于线程，但它们是轻量级的，开销非常小。拥有数万个goroutine的程序并不罕见，而拥有一万个pthreads代价就非常高了。golang在用户态中实现了goroutine。golang运行时为go程序创建的操作系统线程（pthreads）等于GOMAXPROCS的数量。Go协程被golang运行时安排在这些有限的OS线程上。
操作系统调度器 让我们回顾一下操作系统是如何调度进程的。通常情况下，操作系统调度器会保存一份操作系统进程的列表，它们处于正在运行、可运行或不可运行的状态。如果一个进程的运行时间超过了调度器的时间片，它就会抢占该进程，并安排在同一CPU上执行另一个可运行的进程。抢占是通过定时器中断来实现的。定时器中断的频率为调度器时间片的间隔。在一段代码中正在执行的进程会停止执行，保存进程执行上下文并执行中断处理程序。中断处理程序会将执行切换到调度器中。现在，调度器可以决定在这个CPU上执行哪个可运行的进程。调度器会选择一个进程并切换到它的执行上下文。
Golang的调度器 Golang实现了一个可协作的抢占式调度器。它没有实现基于定时器中断的抢占。但是，这个调度器应该方便在一个OS线程上同时运行多个goroutine。Golang在运行时提供的构造体、库和系统调用(？此处翻译的不好，构造体这个说法听着怪怪的)中加入钩子，可以与调度器进行协作。由于它避开了调用进入调度器的计时器，所以将运行时提供的函数作为进入调度器的入口。如果我们设法写一个不使用任何运行时提供的封装函数的goroutine，会发生什么？这正是这里发生的事情。那个goroutine不会调用到调度器，并导致goroutine的抢占。
在上面的程序中，我们执行的goroutine等于GOMAXPROCS（操作系统线程）。主协程是一个额外的goroutine。每个go协程都运行一个无限循环，并带有一个整数增量操作，这为协程提供了没有调用到调度器的范围。因此，所有六个线程（GOMAXPROCS）都在运行无限循环，它们永远不会抢占。处于可运行状态的主协程无法执行，因为这六个线程中的任何一个线程都忙于执行无限循环，所以调度器永远不会被执行。当我们减少1个线程时，现在有一个OS线程变得空闲，能够执行主程序。
(旁注：假设系统是8个CPU，我们GOMAXPROCS减1以后运行程序，就会有一个核是空闲的，此时正好可以进入主线程中执行，虽然原作者这里写的是6，不过我觉得处于无限循环的线程应该等同于threads，当threads等于系统CPU核心数时，由于无限循环，主协程没有机会被调度到，所以就程序没法退出，当将threads头1时，主协程才有机会能够执行，GOMAXPROCS限制的是goroutine的最大并发能力，这个也是由golang自己的调度器实现的，那主协程能运行是由于golang调度所致吗？此处先埋下伏笔。 我分别在不同的go版本下运行了示例程序：1.13、1.14，得到了不同的结果，1.13符合预期，但是1.14下程序却有不同表现，主线程总能得到执行，我想这应该是因为1.14版本的go调度器有较大变化所致，此处先埋点，后开坑)
在现实世界的程序中，这种情况是不太可能发生的，因为我们可能会使用运行时提供的功能，如channels、systemcalls、fmt.Sprint、Mutex、time.Sleep至少一次。你可以在无限循环中添加一个无害的time.Sleep(0)，然后观察程序不再挂起。
结论 虽然出现这个问题的几率非常小，但还是有可能发生。解决这个问题的方法是在这种情况下，从程序中强行调用进入调度器。runtime.Gosched()的调用有利于强制进入调度器。
这篇博文的灵感来自于我的同事，他在玩golang的时候就遇到了这个问题。
(旁注：此文非常有意思，一个简单的示例，却可以发散读者对于调度器的理解，有你当然，这篇文章还没有讲解goroutine为什么轻量，这是另一个有意思的话题，欢迎一起讨论)
 原文链接 pitfall-of-golang-scheduler"><meta itemprop=datePublished content="2021-02-07T15:47:25+08:00"><meta itemprop=dateModified content="2021-02-07T15:47:25+08:00"><meta itemprop=wordCount content="70"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="golang调度器的一个陷阱"><meta name=twitter:description content="让我们快速进入问题，不浪费时间。试着执行下面的golang代码片段。
package main import ( &#34;fmt&#34; &#34;runtime&#34; &#34;time&#34; ) func main() { var x int threads := runtime.GOMAXPROCS(0) println(threads) for i := 0; i < threads; i++ { go func() { for { x++ } }() } time.Sleep(time.Second) fmt.Println(&#34;x =&#34;, x) } 运行代码
$ GOMAXPROCS=8 go run x.go (旁注：熟悉Golang的同道想必知道GOMAXPROCS其实对应的CPU核心数，也就是线程数，这里应该是原作者运行示例时的计算机的CPU核数为8，因为根据文档定义，如果runtime.GOMAXPROCS(0)传入参数小于1，如果特殊指定，GOMAXPROCS就等于CPU核心数)
你观察到程序从未终止吗？这就是我说的golang陷阱。如果你用C/C++写同样的程序，你就不会发现这样的问题。现在让我们修改程序，修改以下一行：
threads := runtime.GOMAXPROCS(0)-1 所以，我们只是减少了1个go协程的数量。如果你在这个改变后重新运行程序，你会发现程序正确地终止，并打印出结果。这非常令人惊讶，不是吗？要了解这个问题背后的原因，我们需要了解一下golang运行时和调度器的实现。
揭开调度器的神秘面纱 Golang提供了用于并发的goroutine。它们类似于线程，但它们是轻量级的，开销非常小。拥有数万个goroutine的程序并不罕见，而拥有一万个pthreads代价就非常高了。golang在用户态中实现了goroutine。golang运行时为go程序创建的操作系统线程（pthreads）等于GOMAXPROCS的数量。Go协程被golang运行时安排在这些有限的OS线程上。
操作系统调度器 让我们回顾一下操作系统是如何调度进程的。通常情况下，操作系统调度器会保存一份操作系统进程的列表，它们处于正在运行、可运行或不可运行的状态。如果一个进程的运行时间超过了调度器的时间片，它就会抢占该进程，并安排在同一CPU上执行另一个可运行的进程。抢占是通过定时器中断来实现的。定时器中断的频率为调度器时间片的间隔。在一段代码中正在执行的进程会停止执行，保存进程执行上下文并执行中断处理程序。中断处理程序会将执行切换到调度器中。现在，调度器可以决定在这个CPU上执行哪个可运行的进程。调度器会选择一个进程并切换到它的执行上下文。
Golang的调度器 Golang实现了一个可协作的抢占式调度器。它没有实现基于定时器中断的抢占。但是，这个调度器应该方便在一个OS线程上同时运行多个goroutine。Golang在运行时提供的构造体、库和系统调用(？此处翻译的不好，构造体这个说法听着怪怪的)中加入钩子，可以与调度器进行协作。由于它避开了调用进入调度器的计时器，所以将运行时提供的函数作为进入调度器的入口。如果我们设法写一个不使用任何运行时提供的封装函数的goroutine，会发生什么？这正是这里发生的事情。那个goroutine不会调用到调度器，并导致goroutine的抢占。
在上面的程序中，我们执行的goroutine等于GOMAXPROCS（操作系统线程）。主协程是一个额外的goroutine。每个go协程都运行一个无限循环，并带有一个整数增量操作，这为协程提供了没有调用到调度器的范围。因此，所有六个线程（GOMAXPROCS）都在运行无限循环，它们永远不会抢占。处于可运行状态的主协程无法执行，因为这六个线程中的任何一个线程都忙于执行无限循环，所以调度器永远不会被执行。当我们减少1个线程时，现在有一个OS线程变得空闲，能够执行主程序。
(旁注：假设系统是8个CPU，我们GOMAXPROCS减1以后运行程序，就会有一个核是空闲的，此时正好可以进入主线程中执行，虽然原作者这里写的是6，不过我觉得处于无限循环的线程应该等同于threads，当threads等于系统CPU核心数时，由于无限循环，主协程没有机会被调度到，所以就程序没法退出，当将threads头1时，主协程才有机会能够执行，GOMAXPROCS限制的是goroutine的最大并发能力，这个也是由golang自己的调度器实现的，那主协程能运行是由于golang调度所致吗？此处先埋下伏笔。 我分别在不同的go版本下运行了示例程序：1.13、1.14，得到了不同的结果，1.13符合预期，但是1.14下程序却有不同表现，主线程总能得到执行，我想这应该是因为1.14版本的go调度器有较大变化所致，此处先埋点，后开坑)
在现实世界的程序中，这种情况是不太可能发生的，因为我们可能会使用运行时提供的功能，如channels、systemcalls、fmt.Sprint、Mutex、time.Sleep至少一次。你可以在无限循环中添加一个无害的time.Sleep(0)，然后观察程序不再挂起。
结论 虽然出现这个问题的几率非常小，但还是有可能发生。解决这个问题的方法是在这种情况下，从程序中强行调用进入调度器。runtime.Gosched()的调用有利于强制进入调度器。
这篇博文的灵感来自于我的同事，他在玩golang的时候就遇到了这个问题。
(旁注：此文非常有意思，一个简单的示例，却可以发散读者对于调度器的理解，有你当然，这篇文章还没有讲解goroutine为什么轻量，这是另一个有意思的话题，欢迎一起讨论)
 原文链接 pitfall-of-golang-scheduler"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">just for fun!</a><div class="flex-l items-center"></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class=mt3><a href="https://www.facebook.com/sharer.php?u=http://example.org/posts/golang%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E9%99%B7%E9%98%B1/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></a><a href="https://twitter.com/share?url=http://example.org/posts/golang%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E9%99%B7%E9%98%B1/&text=golang%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e4%b8%80%e4%b8%aa%e9%99%b7%e9%98%b1" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a><a href="https://www.linkedin.com/shareArticle?mini=true&url=http://example.org/posts/golang%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E9%99%B7%E9%98%B1/&title=golang%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e4%b8%80%e4%b8%aa%e9%99%b7%e9%98%b1" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a></div><h1 class="f1 athelas mt3 mb1">golang调度器的一个陷阱</h1><time class="f6 mv4 dib tracked" datetime=2021-02-07T15:47:25+08:00>February 7, 2021</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>让我们快速进入问题，不浪费时间。试着执行下面的golang代码片段。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;runtime&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>threads</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>GOMAXPROCS</span>(<span style=color:#ae81ff>0</span>)
	println(<span style=color:#a6e22e>threads</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>threads</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
			<span style=color:#66d9ef>for</span> {
				<span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>
			}
		}()
	}
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;x =&#34;</span>, <span style=color:#a6e22e>x</span>)
}
</code></pre></div><p>运行代码</p><pre><code>$ GOMAXPROCS=8 go run x.go
</code></pre><p>(旁注：熟悉Golang的同道想必知道<code>GOMAXPROCS</code>其实对应的CPU核心数，也就是线程数，这里应该是原作者运行示例时的计算机的CPU核数为8，因为根据文档定义，如果<code>runtime.GOMAXPROCS(0)</code>传入参数小于1，如果特殊指定，GOMAXPROCS就等于CPU核心数)</p><p>你观察到程序从未终止吗？这就是我说的golang陷阱。如果你用C/C++写同样的程序，你就不会发现这样的问题。现在让我们修改程序，修改以下一行：</p><pre><code>threads := runtime.GOMAXPROCS(0)-1
</code></pre><p>所以，我们只是减少了1个go协程的数量。如果你在这个改变后重新运行程序，你会发现程序正确地终止，并打印出结果。这非常令人惊讶，不是吗？要了解这个问题背后的原因，我们需要了解一下golang运行时和调度器的实现。</p><h3 id=揭开调度器的神秘面纱>揭开调度器的神秘面纱</h3><p>Golang提供了用于并发的goroutine。它们类似于线程，但它们是轻量级的，开销非常小。拥有数万个goroutine的程序并不罕见，而拥有一万个pthreads代价就非常高了。golang在用户态中实现了goroutine。golang运行时为go程序创建的操作系统线程（pthreads）等于GOMAXPROCS的数量。Go协程被golang运行时安排在这些有限的OS线程上。</p><h2 id=操作系统调度器>操作系统调度器</h2><p>让我们回顾一下操作系统是如何调度进程的。通常情况下，操作系统调度器会保存一份操作系统进程的列表，它们处于正在运行、可运行或不可运行的状态。如果一个进程的运行时间超过了调度器的时间片，它就会抢占该进程，并安排在同一CPU上执行另一个可运行的进程。抢占是通过定时器中断来实现的。定时器中断的频率为调度器时间片的间隔。在一段代码中正在执行的进程会停止执行，保存进程执行上下文并执行中断处理程序。中断处理程序会将执行切换到调度器中。现在，调度器可以决定在这个CPU上执行哪个可运行的进程。调度器会选择一个进程并切换到它的执行上下文。</p><h3 id=golang的调度器>Golang的调度器</h3><p>Golang实现了一个可协作的抢占式调度器。它没有实现基于定时器中断的抢占。但是，这个调度器应该方便在一个OS线程上同时运行多个goroutine。Golang在运行时提供的构造体、库和系统调用(？此处翻译的不好，构造体这个说法听着怪怪的)中加入钩子，可以与调度器进行协作。由于它避开了调用进入调度器的计时器，所以将运行时提供的函数作为进入调度器的入口。如果我们设法写一个不使用任何运行时提供的封装函数的goroutine，会发生什么？这正是这里发生的事情。那个goroutine不会调用到调度器，并导致goroutine的抢占。</p><p>在上面的程序中，我们执行的goroutine等于GOMAXPROCS（操作系统线程）。主协程是一个额外的goroutine。每个go协程都运行一个无限循环，并带有一个整数增量操作，这为协程提供了没有调用到调度器的范围。因此，所有六个线程（GOMAXPROCS）都在运行无限循环，它们永远不会抢占。处于可运行状态的主协程无法执行，因为这六个线程中的任何一个线程都忙于执行无限循环，所以调度器永远不会被执行。当我们减少1个线程时，现在有一个OS线程变得空闲，能够执行主程序。</p><p>(旁注：假设系统是8个CPU，我们GOMAXPROCS减1以后运行程序，就会有一个核是空闲的，此时正好可以进入主线程中执行，虽然原作者这里写的是6，不过我觉得处于无限循环的线程应该等同于threads，当threads等于系统CPU核心数时，由于无限循环，主协程没有机会被调度到，所以就程序没法退出，当将threads头1时，主协程才有机会能够执行，GOMAXPROCS限制的是goroutine的最大并发能力，这个也是由golang自己的调度器实现的，那主协程能运行是由于golang调度所致吗？此处先埋下伏笔。
我分别在不同的go版本下运行了示例程序：1.13、1.14，得到了不同的结果，1.13符合预期，但是1.14下程序却有不同表现，主线程总能得到执行，我想这应该是因为1.14版本的go调度器有较大变化所致，此处先埋点，后开坑)</p><p>在现实世界的程序中，这种情况是不太可能发生的，因为我们可能会使用运行时提供的功能，如<code>channels</code>、<code>systemcalls</code>、<code>fmt.Sprint</code>、<code>Mutex</code>、<code>time.Sleep</code>至少一次。你可以在无限循环中添加一个无害的<code>time.Sleep(0)</code>，然后观察程序不再挂起。</p><h2 id=结论>结论</h2><p>虽然出现这个问题的几率非常小，但还是有可能发生。解决这个问题的方法是在这种情况下，从程序中强行调用进入调度器。<code>runtime.Gosched()</code>的调用有利于强制进入调度器。</p><p>这篇博文的灵感来自于我的同事，他在玩golang的时候就遇到了这个问题。</p><p>(旁注：此文非常有意思，一个简单的示例，却可以发散读者对于调度器的理解，有你当然，这篇文章还没有讲解goroutine为什么轻量，这是另一个有意思的话题，欢迎一起讨论)</p><hr><p>原文链接 <a href=http://www.sarathlakshman.com/2016/06/15/pitfall-of-golang-scheduler>pitfall-of-golang-scheduler</a></p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=http://example.org/>&copy; just for fun! 2021</a><div></div></div></footer></body></html>